REFLECT:

Name    : Tarun Thomas 
ID      : 113605224
Section : NCC


During this workshop, I learned how to copy an item. To begin, there are two methods for copying an object. It is possible to copy using a constructor or the operator "=". Shallow and deep copies are created throughout the copying process. However, shallow copying has the disadvantage of causing a memory leak if a variable with dynamic memory is duplicated. This is due to the fact that while copying, only pointers are transferred, not values. In this workshop, I used deep copy. First, as a parameter, the copy constructor accepts a constant-type object reference, such as Stats(const Stats &src). 

The values of the received references are then deep copied to the "this" object. The most critical aspect of copying is to ensure that "self-assignment" is not checked. In other words, the copy was only performed if the object does not replicate itself. A constant-type object reference, such as a copy constructor, is also passed as a parameter to the method using the operator "=". Stats &operator=(const Stats &source), for example. The operator has an object reference as a return type, but the other does not. And, unlike the copy constructor, I overwrote the value of the "this" object with the value of the operand object in this workshop. In other words, I deleted the dynamic memory of the "this" object, reassigned the size of dynamic memory in the operand object, and copied it deeply. Of course, I checked "self-assignment" here as well, too. Lastly, I returned "this" object.

I now know how to read and write files. Not only did I read and write files in this workshop, but I also overloaded insertion and extraction operators. It received both ostream and istream as parameters, as well as object references, at this time. The two forms were used in "helper functions" such as std::ostream & operator (std:ostream & ostr, const Stats &src) and std::istream & operator>>(std:istream &istr, Stats &src). These operators were used to enter or read the values of the member variables and were supplied as a parameter to a function specified within the class of reading and writing the file. It is also a good practise to use is_open() to ensure that you read the file correctly before reading it. Because the length of the value in the file is uncertain, I read it using string when I use getline(). I need to use "c_str" to convert the string to C-style so that I can later insert the value into the character pointer variable. I must declare the string library before I can utilise these string functions.